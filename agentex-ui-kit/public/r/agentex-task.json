{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "agentex-task",
  "type": "registry:block",
  "title": "Agentex Task",
  "description": "Task context and utilities for managing Agentex tasks.",
  "dependencies": [
    "agentex@0.1.0-alpha.6",
    "react",
    "uuid",
    "zustand"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/agentex-root.json"
  ],
  "files": [
    {
      "path": "registry/agentex/agentex-task/components/agentex-task.tsx",
      "content": "import { useAgentexRootController } from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-controller\";\nimport {\n  AgentexRootStore,\n  useAgentexRootStoreAPI,\n} from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-store\";\nimport type { PendingMessage } from \"@/registry/agentex/agentex-root/lib/pending-message\";\nimport { handleSendMessage } from \"@/registry/agentex/agentex-task/hooks/use-agentex-task-controller\";\nimport {\n  AgentexTaskStore,\n  AgentexTaskStoreContext,\n  createAgentexTaskStore,\n} from \"@/registry/agentex/agentex-task/hooks/use-agentex-task-store\";\nimport { subscribeTaskState } from \"agentex/lib\";\nimport type { Task } from \"agentex/resources\";\nimport { useEffect, useRef, useState } from \"react\";\n\nfunction bootstrapTask(\n  rootStore: AgentexRootStore,\n  taskID: Task[\"id\"],\n  signal: AbortSignal,\n  onError: (errorMessage: string) => void,\n  acquirePendingMessage: (\n    callback: (pendingMessage: PendingMessage | null) => Promise<void>\n  ) => void\n): Promise<AgentexTaskStore> {\n  const initialRootState = rootStore.getState();\n\n  return new Promise((resolve) => {\n    let agentsInitialized = false;\n    let messagesInitialized = false;\n\n    const initializerCallback = (event: \"agents\" | \"messages\") => {\n      if (event === \"agents\") {\n        agentsInitialized = true;\n      } else if (event === \"messages\") {\n        messagesInitialized = true;\n      }\n\n      if (!agentsInitialized || !messagesInitialized) {\n        return;\n      }\n\n      // TODO: move this to the createTask function and make sure we get all the deltas we need\n      // Send any queued pending messages for this task\n      // This is done during bootstrapping rather than during createTask to make sure no deltas are missed.\n      acquirePendingMessage(async (pendingMessage) => {\n        if (pendingMessage !== null) {\n          // Check if we should still send this message (avoid spam from rapid task creation)\n          const messagesBeforeSend = await rootStore\n            .getState()\n            .agentexClient.messages.list({ task_id: taskID }, { signal });\n\n          if (\n            messagesBeforeSend.filter((m) => m.content.author === \"user\")\n              .length <= pendingMessage.checkMaxUserMessagesBeforeSend\n          ) {\n            await handleSendMessage(\n              rootStore,\n              store,\n              pendingMessage.agentID,\n              pendingMessage.content\n            );\n          }\n        }\n\n        // Mark pending messages as processed to enable user messaging\n        store.setState({ isPendingMessagesSent: true });\n      });\n      resolve(store);\n    };\n\n    const store = createAgentexTaskStore({\n      signal,\n      taskID,\n      taskAgentIDs: [],\n      messages: [],\n      deltaAccumulator: null,\n    });\n\n    subscribeTaskState(\n      initialRootState.agentexClient,\n      { taskID },\n      {\n        onAgentsChange(updatedTaskAgents) {\n          store.setState({ taskAgentIDs: updatedTaskAgents.map((a) => a.id) });\n\n          rootStore.setState((prev) => ({\n            agents: prev.agents.map((a) => {\n              const updatedTaskAgent = updatedTaskAgents.find(\n                (agent) => agent.id === a.id\n              );\n              if (updatedTaskAgent !== undefined) {\n                return updatedTaskAgent;\n              }\n              return a;\n            }),\n          }));\n\n          initializerCallback(\"agents\");\n        },\n        onError(errorMessage) {\n          onError(errorMessage);\n        },\n        onMessagesChange(messages) {\n          store.setState({ messages: [...messages] });\n          initializerCallback(\"messages\");\n        },\n        onStreamStatusChange(streamStatus) {\n          switch (streamStatus) {\n            case \"connected\":\n              store.setState({ streamStatus: \"ready\" });\n              break;\n            case \"reconnecting\":\n              store.setState({ streamStatus: \"reconnecting\" });\n              break;\n            case \"disconnected\":\n              store.setState({ streamStatus: \"error\" });\n              break;\n            default:\n              streamStatus satisfies never;\n              onError(`Unknown stream status: ${streamStatus}`);\n              break;\n          }\n        },\n        onTaskChange(updatedTask) {\n          rootStore.setState((prev) => ({\n            tasks: prev.tasks.map((t) =>\n              t.id === updatedTask.id ? updatedTask : t\n            ),\n          }));\n        },\n      },\n      { signal }\n    );\n  });\n}\n\ntype AgentexTaskProps = {\n  taskID: Task[\"id\"];\n  fallback?: React.ReactNode;\n  children?: React.ReactNode;\n  onError?: (error: unknown) => void;\n};\n\nfunction AgentexTask({\n  children,\n  fallback,\n  taskID,\n  onError,\n}: AgentexTaskProps) {\n  const [store, setStore] = useState<AgentexTaskStore | null>(null);\n  const rootStore = useAgentexRootStoreAPI();\n  const { popPendingMessageForTask } = useAgentexRootController();\n\n  const onErrorRef = useRef<typeof onError>(onError);\n  // keep onErrorRef in sync\n  useEffect(() => {\n    onErrorRef.current = onError;\n  }, [onError]);\n\n  // bootstrap\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    setStore(null);\n\n    bootstrapTask(\n      rootStore,\n      taskID,\n      abortController.signal,\n      (errorMessage) => onErrorRef.current?.({ message: errorMessage }),\n      (...args) => popPendingMessageForTask(taskID, ...args)\n    ).then(\n      (store) => {\n        setStore(store);\n      },\n      (error) => {\n        if (abortController.signal.aborted) {\n          return;\n        }\n        if (onErrorRef.current !== undefined) {\n          onErrorRef.current(error);\n          return;\n        }\n        throw error;\n      }\n    );\n\n    return () => {\n      abortController.abort();\n    };\n  }, [setStore, rootStore, taskID, popPendingMessageForTask]);\n\n  // loading\n  if (store === null) {\n    return <>{fallback}</>;\n  }\n\n  // render\n  return (\n    <AgentexTaskStoreContext.Provider value={store}>\n      {children}\n    </AgentexTaskStoreContext.Provider>\n  );\n}\n\nexport { AgentexTask };\n",
      "type": "registry:component"
    },
    {
      "path": "registry/agentex/agentex-task/hooks/use-agentex-task-controller.ts",
      "content": "import {\n  AgentexRootStore,\n  useAgentexRootStoreAPI,\n} from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-store\";\nimport {\n  AgentexTaskStore,\n  AgentexTaskStoreContext,\n  useAgentexTask,\n} from \"@/registry/agentex/agentex-task/hooks/use-agentex-task-store\";\nimport {\n  agentRPCNonStreaming,\n  agentRPCWithStreaming,\n  aggregateMessageEvents,\n} from \"agentex/lib\";\nimport type { Agent, TaskMessage, TaskMessageContent } from \"agentex/resources\";\nimport { useCallback, useContext, useMemo } from \"react\";\nimport { v4 } from \"uuid\";\nimport { useStore } from \"zustand\";\n\nasync function handleSendMessage(\n  rootStore: AgentexRootStore,\n  taskStore: AgentexTaskStore,\n  agentID: Agent[\"id\"],\n  content: TaskMessageContent\n): Promise<void> {\n  const initialState = taskStore.getState();\n  const initialRootState = rootStore.getState();\n  const agent = initialRootState.agents.find((agent) => agent.id === agentID);\n\n  if (agent === undefined) {\n    throw new Error(`Agent with ID ${agentID} not found in AgentexRootStore`);\n  }\n\n  // Route message handling based on agent communication pattern\n  switch (agent.acp_type) {\n    case \"agentic\": {\n      // Fire-and-forget pattern: send event, agent handles async response\n      const response = await agentRPCNonStreaming(\n        initialRootState.agentexClient,\n        { agentID },\n        \"event/send\",\n        { task_id: initialState.taskID, content },\n        { signal: initialState.signal }\n      );\n\n      if (response.error != null) {\n        throw new Error(response.error.message);\n      }\n\n      break;\n    }\n    case \"sync\": {\n      // Streaming pattern: immediate response with real-time updates\n      // First display user message optimistically for better UX\n      const tempUserMessage: TaskMessage = {\n        id: v4(),\n        content,\n        task_id: initialState.taskID,\n        created_at: new Date().toISOString(),\n        streaming_status: \"DONE\",\n        updated_at: new Date().toISOString(),\n      };\n      taskStore.setState({\n        messages: [...initialState.messages, tempUserMessage],\n      });\n\n      // Stream agent response and update UI in real-time\n      for await (const response of agentRPCWithStreaming(\n        initialRootState.agentexClient,\n        { agentID },\n        \"message/send\",\n        { task_id: initialState.taskID, content },\n        { signal: initialState.signal }\n      )) {\n        if (response.error != null) {\n          throw new Error(response.error.message);\n        }\n\n        const { messages, deltaAccumulator } = taskStore.getState();\n        const result = aggregateMessageEvents(messages, deltaAccumulator, [\n          response.result,\n        ]);\n\n        taskStore.setState({\n          messages: result.messages,\n          deltaAccumulator: result.deltaAccumulator,\n        });\n      }\n\n      // Replace temporary user message with server-authoritative version\n      const beforeSyncState = taskStore.getState();\n      const finalMessages = await rootStore\n        .getState()\n        .agentexClient.messages.list(\n          { task_id: beforeSyncState.taskID },\n          { signal: beforeSyncState.signal }\n        );\n      taskStore.setState({\n        messages: finalMessages,\n      });\n      break;\n    }\n    default: {\n      throw new Error(\n        `Unsupported agent acp_type: ${agent.acp_type satisfies never}`\n      );\n    }\n  }\n}\n\n/**\n * TODO: add more controls\n */\ntype AgentexTaskController = {\n  isSendMessageEnabled: boolean;\n  sendMessage: (\n    agentID: Agent[\"id\"],\n    content: TaskMessageContent\n  ) => Promise<void>;\n};\n\nfunction useAgentexTaskController(): AgentexTaskController {\n  const store = useContext(AgentexTaskStoreContext);\n  if (store === null) {\n    throw new Error(\"useAgentexTaskController must be used within AgentexTask\");\n  }\n  const rootStore = useAgentexRootStoreAPI();\n\n  const task = useAgentexTask();\n  const isPendingMessagesSent = useStore(store, (s) => s.isPendingMessagesSent);\n\n  // Only allow messaging when task exists, is running, and initial pending messages are handled\n  const isSendMessageEnabled =\n    task !== undefined && task.status === \"RUNNING\" && isPendingMessagesSent;\n\n  const sendMessage = useCallback<AgentexTaskController[\"sendMessage\"]>(\n    (agentID, content) => handleSendMessage(rootStore, store, agentID, content),\n    [store, rootStore]\n  );\n\n  return useMemo(\n    () => ({\n      isSendMessageEnabled,\n      sendMessage,\n    }),\n    [isSendMessageEnabled, sendMessage]\n  );\n}\n\nexport { handleSendMessage, useAgentexTaskController };\nexport type { AgentexTaskController };\n\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/agentex/agentex-task/hooks/use-agentex-task-store.ts",
      "content": "import { useAgentexRootStore } from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-store\";\nimport type { IDeltaAccumulator } from \"agentex/lib\";\nimport type { Agent, Task, TaskMessage } from \"agentex/resources\";\nimport { createContext, useContext, useMemo } from \"react\";\nimport { createStore, StoreApi, useStore } from \"zustand\";\n\ntype AgentexTaskStoreProps = {\n  signal: AbortSignal;\n  taskID: Task[\"id\"];\n  /**\n   * Agents that this can use.\n   */\n  taskAgentIDs: Agent[\"id\"][];\n  messages: TaskMessage[];\n  /**\n   * This is only used for sync ACP agents.\n   */\n  deltaAccumulator: IDeltaAccumulator | null;\n};\n\ntype AgentexTaskState = AgentexTaskStoreProps & {\n  streamStatus: \"loading\" | \"ready\" | \"reconnecting\" | \"error\";\n  isPendingMessagesSent: boolean;\n};\n\ntype AgentexTaskStore = StoreApi<AgentexTaskState>;\n\nfunction createAgentexTaskStore(\n  initialState: AgentexTaskStoreProps\n): AgentexTaskStore {\n  return createStore(() => ({\n    ...initialState,\n    streamStatus: \"loading\",\n    isPendingMessagesSent: false,\n  }));\n}\n\nconst AgentexTaskStoreContext = createContext<AgentexTaskStore | null>(null);\n\nfunction useAgentexTaskStore<T>(selector: (state: AgentexTaskState) => T): T {\n  const store = useContext(AgentexTaskStoreContext);\n  if (store === null) {\n    throw new Error(\"useAgentexTaskStore must be used within AgentexTask\");\n  }\n  return useStore(store, selector);\n}\n\nfunction useAgentexTask(): Task | undefined {\n  const taskID = useAgentexTaskStore((s) => s.taskID);\n  const tasks = useAgentexRootStore((s) => s.tasks);\n  return tasks.find((t) => t.id === taskID);\n}\n\nfunction useAgentexTaskAgents(): Agent[] {\n  const agents = useAgentexRootStore((s) => s.agents);\n  const taskAgentIDs = useAgentexTaskStore((s) => s.taskAgentIDs);\n  return useMemo(\n    () => agents.filter((agent) => taskAgentIDs.includes(agent.id)),\n    [agents, taskAgentIDs]\n  );\n}\n\nexport {\n  AgentexTaskStoreContext,\n  createAgentexTaskStore,\n  useAgentexTask,\n  useAgentexTaskAgents,\n  useAgentexTaskStore,\n};\nexport type { AgentexTaskState, AgentexTaskStore, AgentexTaskStoreProps };\n",
      "type": "registry:hook"
    }
  ]
}