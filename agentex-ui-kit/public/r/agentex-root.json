{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "agentex-root",
  "type": "registry:block",
  "title": "Agentex Root",
  "description": "Shared context for an Agentex application.",
  "dependencies": [
    "agentex@0.1.0-alpha.6",
    "react",
    "zustand"
  ],
  "files": [
    {
      "path": "registry/agentex/agentex-root/components/agentex-root.tsx",
      "content": "import {\n  AgentexRootStore,\n  AgentexRootStoreContext,\n  createAgentexRootStore,\n} from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-store\";\nimport type AgentexSDK from \"agentex\";\nimport { useEffect, useRef, useState } from \"react\";\n\ntype AgentexRootProps = {\n  agentexClient: AgentexSDK;\n  fallback?: React.ReactNode;\n  children?: React.ReactNode;\n  onError?: ((error: unknown) => void) | undefined;\n};\n\nfunction AgentexRoot({\n  children,\n  fallback,\n  agentexClient,\n  onError,\n}: AgentexRootProps) {\n  const [store, setStore] = useState<AgentexRootStore | null>(null);\n\n  const onErrorRef = useRef<typeof onError>(onError);\n  // keep onErrorRef in sync\n  useEffect(() => {\n    onErrorRef.current = onError;\n  }, [onError]);\n\n  // bootstrap\n  useEffect(() => {\n    const abortController = new AbortController();\n\n    setStore(null);\n\n    Promise.all([\n      agentexClient.agents.list(\n        undefined, // query\n        { signal: abortController.signal }\n      ),\n      agentexClient.tasks.list(\n        undefined, // query\n        { signal: abortController.signal }\n      ),\n    ]).then(\n      ([agents, tasks]) => {\n        if (abortController.signal.aborted) return;\n        setStore(\n          createAgentexRootStore({\n            agentexClient,\n            agents,\n            tasks,\n          })\n        );\n      },\n      (error) => {\n        if (abortController.signal.aborted) {\n          return;\n        }\n        if (onErrorRef.current !== undefined) {\n          onErrorRef.current(error);\n          return;\n        }\n        throw error;\n      }\n    );\n\n    return () => {\n      abortController.abort();\n    };\n  }, [agentexClient, setStore]);\n\n  // loading\n  if (store === null) {\n    return <>{fallback}</>;\n  }\n\n  // render\n  return (\n    <AgentexRootStoreContext.Provider value={store}>\n      {children}\n    </AgentexRootStoreContext.Provider>\n  );\n}\n\nexport { AgentexRoot };\n",
      "type": "registry:component"
    },
    {
      "path": "registry/agentex/agentex-root/hooks/use-agentex-root-controller.ts",
      "content": "import { useAgentexRootStoreAPI } from \"@/registry/agentex/agentex-root/hooks/use-agentex-root-store\";\nimport {\n  PendingMessage,\n  PendingMessageLock,\n} from \"@/registry/agentex/agentex-root/lib/pending-message\";\nimport { agentRPCNonStreaming } from \"agentex/lib\";\nimport type { Agent, Task, TaskMessageContent } from \"agentex/resources\";\nimport { useMemo } from \"react\";\n\ntype AgentexRootController = {\n  /**\n   * IMPORTANT: This function does not actually send `messageContent` to the task. It only creates a `PendingMessage`.\n   * The message is sent automatically when `AgentexTask` is first rendered with this taskID.\n   * This is because `AgentexTask` needs to be able to stream the response into its state.\n   * If you don't want to display any UI for some reason, you can also just render an empty `<AgentexTask />` somewhere.\n   */\n  createTask: (\n    agentID: Agent[\"id\"],\n    name: string | null,\n    messageContent: TaskMessageContent | null,\n    taskParams?: Record<string, unknown> | null\n  ) => Promise<Task>;\n  /**\n   * @param callback This is called with the pending message (if any) once other callers release the lock.\n   * The pending message is removed if the promise returned by the callback resolves.\n   * If the promise is rejected, the pending message is not removed.\n   */\n  popPendingMessageForTask: (\n    taskID: Task[\"id\"],\n    callback: (pendingMessage: PendingMessage | null) => Promise<void>\n  ) => void;\n};\n\nfunction useAgentexRootController(): AgentexRootController {\n  const store = useAgentexRootStoreAPI();\n\n  return useMemo(\n    () => ({\n      createTask: async (agentID, name, messageContent, params) => {\n        const response = await agentRPCNonStreaming(\n          store.getState().agentexClient,\n          { agentID },\n          \"task/create\",\n          {\n            name,\n            ...(params !== undefined ? { params } : null),\n          }\n        );\n\n        if (response.error != null) {\n          throw new Error(response.error.message);\n        }\n\n        // Add task to store if it doesn't already exist (avoid duplicates)\n        const beforeUpdateState = store.getState();\n        if (beforeUpdateState.tasks.every((t) => t.id !== response.result.id)) {\n          store.setState({\n            tasks: [...beforeUpdateState.tasks, response.result],\n          });\n        }\n\n        // Queue message to be sent once task context is initialized\n        if (messageContent !== null) {\n          store.getState()._taskToPendingMessage.set(\n            response.result.id,\n            new PendingMessageLock({\n              agentID,\n              content: messageContent,\n              checkMaxUserMessagesBeforeSend: 0,\n            })\n          );\n        }\n\n        return response.result;\n      },\n      popPendingMessageForTask: (taskID, callback) => {\n        const lock = store.getState()._taskToPendingMessage.get(taskID);\n        if (lock === undefined) {\n          callback(null);\n        } else {\n          lock\n            .acquire()\n            .then(callback)\n            .then(\n              // if callback resolves, release the lock and pop the pending message\n              () => {\n                lock.release(true);\n              },\n              // if callback rejects, release the lock but do not pop the pending message\n              () => {\n                lock.release(false);\n              }\n            )\n            // cleanup map if the pending message lock is done\n            .finally(() => {\n              if (lock.isDone) {\n                store.getState()._taskToPendingMessage.delete(taskID);\n              }\n            });\n        }\n      },\n    }),\n    [store]\n  );\n}\n\nexport { useAgentexRootController };\nexport type { AgentexRootController };\n\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/agentex/agentex-root/hooks/use-agentex-root-store.ts",
      "content": "import { PendingMessageLock } from \"@/registry/agentex/agentex-root/lib/pending-message\";\nimport type AgentexSDK from \"agentex\";\nimport type { Agent, Task } from \"agentex/resources\";\nimport { createContext, useContext } from \"react\";\nimport { createStore, StoreApi, useStore } from \"zustand\";\n\ntype AgentexRootStoreProps = {\n  agentexClient: AgentexSDK;\n  agents: Agent[];\n  tasks: Task[];\n};\n\ntype AgentexRootState = AgentexRootStoreProps & {\n  /**\n   * Map from Task ID to pending messages that should be sent after task creation.\n   *\n   * CRITICAL: This map instance is stable across store updates to avoid breaking\n   * pending message locks that may be held by async operations. Do not recreate.\n   *\n   * GOTCHA: Never use this in React render logic - the map reference never changes\n   * so React won't re-render when entries are added/removed.\n   */\n  _taskToPendingMessage: Map<Task[\"id\"], PendingMessageLock>;\n};\n\ntype AgentexRootStore = StoreApi<AgentexRootState>;\n\nfunction createAgentexRootStore(\n  initialState: AgentexRootStoreProps\n): AgentexRootStore {\n  return createStore(() => ({\n    ...initialState,\n    _taskToPendingMessage: new Map(),\n  }));\n}\n\nconst AgentexRootStoreContext = createContext<AgentexRootStore | null>(null);\n\nfunction useAgentexRootStore<T>(selector: (state: AgentexRootState) => T): T {\n  const store = useContext(AgentexRootStoreContext);\n  if (store === null) {\n    throw new Error(\n      \"useAgentexRootStore must be used within AgentexRootStoreContext\"\n    );\n  }\n  return useStore(store, selector);\n}\n\nfunction useAgentexRootStoreAPI(): AgentexRootStore {\n  const store = useContext(AgentexRootStoreContext);\n  if (store === null) {\n    throw new Error(\n      \"useAgentexRootStoreAPI must be used within AgentexRootStoreContext\"\n    );\n  }\n  return store;\n}\n\nexport {\n  AgentexRootStoreContext,\n  createAgentexRootStore,\n  useAgentexRootStore,\n  useAgentexRootStoreAPI,\n};\nexport type { AgentexRootState, AgentexRootStore, AgentexRootStoreProps };\n",
      "type": "registry:hook"
    },
    {
      "path": "registry/agentex/agentex-root/lib/pending-message.ts",
      "content": "import type { Agent, TaskMessageContent } from \"agentex/resources\";\n\ntype PendingMessage = {\n  agentID: Agent[\"id\"];\n  content: TaskMessageContent;\n  /**\n   * Used to reduce the number of duplicate pending messages from being sent.\n   * This pending message will be ignored if there are more than `checkMaxUserMessagesBeforeSend` user messages for this task.\n   */\n  checkMaxUserMessagesBeforeSend: number;\n};\n\n/**\n * Thread-safe lock for managing pending messages that need to be sent after task creation.\n * Ensures only one consumer can access the pending message at a time.\n */\nclass PendingMessageLock {\n  private message: PendingMessage | null;\n  private isLocked = false;\n  private waiting: ((message: PendingMessage | null) => void)[] = [];\n\n  constructor(message: PendingMessage) {\n    this.message = message;\n  }\n\n  /**\n   * Acquire exclusive access to the pending message.\n   * If already locked, queues the request until the lock is released.\n   */\n  acquire(): Promise<PendingMessage | null> {\n    if (this.isLocked) {\n      return new Promise((resolve) => {\n        this.waiting.push(resolve);\n      });\n    }\n\n    this.isLocked = true;\n    return Promise.resolve(this.message);\n  }\n\n  /**\n   * Release the lock and optionally consume the pending message.\n   * If there are waiting callers, immediately passes the lock to the next one.\n   * \n   * @param shouldPopMessage If true, removes the message (consumed successfully)\n   */\n  release(shouldPopMessage: boolean): void {\n    if (!this.isLocked) {\n      throw new Error(\"Cannot release a lock that is not acquired.\");\n    }\n\n    if (shouldPopMessage) {\n      this.message = null;\n    }\n\n    const next = this.waiting.shift();\n    if (next === undefined) {\n      this.isLocked = false;\n    } else {\n      // Pass lock directly to next waiting caller\n      next(this.message);\n    }\n  }\n\n  /**\n   * Returns true when the lock can be safely removed from the map.\n   * This happens when message is consumed and no one is waiting.\n   */\n  get isDone(): boolean {\n    return !this.isLocked && this.waiting.length === 0 && this.message === null;\n  }\n}\n\nexport { PendingMessageLock };\nexport type { PendingMessage };\n",
      "type": "registry:lib"
    }
  ]
}