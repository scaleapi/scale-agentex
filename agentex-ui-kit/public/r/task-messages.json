{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "task-messages",
  "type": "registry:ui",
  "title": "Task Messages",
  "description": "Component for displaying a list of task messages.",
  "dependencies": [
    "agentex@0.1.0-alpha.6",
    "react"
  ],
  "registryDependencies": [
    "http://localhost:3000/r/task-message-data-content.json",
    "http://localhost:3000/r/task-message-reasoning-content.json",
    "http://localhost:3000/r/task-message-text-content.json",
    "http://localhost:3000/r/task-message-tool-pair.json"
  ],
  "files": [
    {
      "path": "registry/agentex/task-messages/task-messages.tsx",
      "content": "import { TaskMessageDataContentComponent } from \"@/registry/agentex/task-message-data-content/task-message-data-content\";\nimport { TaskMessageReasoningContentComponent } from \"@/registry/agentex/task-message-reasoning-content/task-message-reasoning-content\";\nimport { TaskMessageTextContentComponent } from \"@/registry/agentex/task-message-text-content/task-message-text-content\";\nimport {\n  MemoizedTaskMessageToolPairComponent,\n  TaskMessageToolPairComponent,\n} from \"@/registry/agentex/task-message-tool-pair/task-message-tool-pair\";\nimport type {\n  TaskMessage,\n  ToolRequestContent,\n  ToolResponseContent,\n} from \"agentex/resources\";\nimport { memo, useMemo } from \"react\";\n\ntype TaskMessageComponentProps = {\n  message: TaskMessage;\n  theme: \"dark\" | \"light\";\n};\n\nfunction TaskMessageComponent({ message, theme }: TaskMessageComponentProps) {\n  if (message.content.type === \"text\") {\n    return (\n      <TaskMessageTextContentComponent\n        content={message.content}\n        theme={theme}\n      />\n    );\n  }\n  if (message.content.type === \"data\") {\n    return (\n      <TaskMessageDataContentComponent\n        content={message.content}\n        theme={theme}\n      />\n    );\n  }\n  if (message.content.type === \"reasoning\") {\n    return <TaskMessageReasoningContentComponent content={message.content} />;\n  }\n\n  message.content.type satisfies \"tool_request\" | \"tool_response\" | undefined;\n\n  return null;\n}\n\nconst MemoizedTaskMessageComponent = memo(TaskMessageComponent);\n\ntype TaskMessagesComponentProps = {\n  messages: TaskMessage[];\n  theme: \"dark\" | \"light\";\n};\n\nfunction TaskMessagesComponent({\n  messages,\n  theme,\n}: TaskMessagesComponentProps) {\n  const toolCallIdToResponseMap = new Map(\n    messages\n      .filter(\n        (m): m is TaskMessage & { content: ToolResponseContent } =>\n          m.content.type === \"tool_response\"\n      )\n      .map((m) => [m.content.tool_call_id, m])\n  );\n\n  return (\n    <>\n      {messages.map((m, index) => {\n        const { content } = m;\n        switch (content.type) {\n          case \"text\":\n          case \"data\":\n          case \"reasoning\":\n            return (\n              <TaskMessageComponent key={index} message={m} theme={theme} />\n            );\n          case \"tool_request\":\n            return (\n              <TaskMessageToolPairComponent\n                key={index}\n                theme={theme}\n                toolRequestMessage={{\n                  ...m,\n                  content,\n                }}\n                toolResponseMessage={toolCallIdToResponseMap.get(\n                  content.tool_call_id\n                )}\n              />\n            );\n          case \"tool_response\":\n            return null;\n          default:\n            content.type satisfies undefined;\n            return null;\n        }\n      })}\n    </>\n  );\n}\n\nfunction MemoizedTaskMessagesComponentImpl({\n  messages,\n  theme,\n}: TaskMessagesComponentProps) {\n  const toolCallIdToResponseMap = useMemo<\n    Map<string, TaskMessage & { content: ToolResponseContent }>\n  >(\n    () =>\n      new Map(\n        messages\n          .filter(\n            (m): m is TaskMessage & { content: ToolResponseContent } =>\n              m.content.type === \"tool_response\"\n          )\n          .map((m) => [m.content.tool_call_id, m])\n      ),\n    [messages]\n  );\n\n  return (\n    <>\n      {messages.map((m, index) => {\n        switch (m.content.type) {\n          case \"text\":\n          case \"data\":\n          case \"reasoning\":\n            return (\n              <MemoizedTaskMessageComponent\n                key={index}\n                message={m}\n                theme={theme}\n              />\n            );\n          case \"tool_request\":\n            return (\n              <MemoizedTaskMessageToolPairComponent\n                key={index}\n                theme={theme}\n                toolRequestMessage={\n                  m as TaskMessage & { content: ToolRequestContent }\n                }\n                toolResponseMessage={toolCallIdToResponseMap.get(\n                  m.content.tool_call_id\n                )}\n              />\n            );\n          case \"tool_response\":\n            return null;\n          default:\n            m.content.type satisfies undefined;\n            return null;\n        }\n      })}\n    </>\n  );\n}\n\nconst MemoizedTaskMessagesComponent = memo(MemoizedTaskMessagesComponentImpl);\n\nexport { MemoizedTaskMessagesComponent, TaskMessagesComponent };\n",
      "type": "registry:ui"
    }
  ]
}