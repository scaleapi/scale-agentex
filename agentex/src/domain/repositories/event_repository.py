from typing import Annotated

from fastapi import Depends
from sqlalchemy import and_
from sqlalchemy.future import select
from src.adapters.crud_store.adapter_postgres import (
    PostgresCRUDRepository,
    async_sql_exception_handler,
)
from src.adapters.orm import EventORM
from src.config.dependencies import DDatabaseAsyncReadWriteSessionMaker
from src.domain.entities.events import EventEntity
from src.domain.entities.task_messages import TaskMessageContentEntity
from src.utils.logging import make_logger

logger = make_logger(__name__)


class EventRepository(PostgresCRUDRepository[EventORM, EventEntity]):
    def __init__(
        self,
        async_read_write_session_maker: DDatabaseAsyncReadWriteSessionMaker,
    ):
        super().__init__(async_read_write_session_maker, EventORM, EventEntity)
        self.async_read_write_session_maker = async_read_write_session_maker

    # Have to do this because the sequence_id is automatically generated by the ORM
    async def create(
        self,
        id: str,
        task_id: str,
        agent_id: str,
        content: TaskMessageContentEntity | None = None,
    ) -> EventEntity:
        async with (
            self.start_async_db_session(True) as session,
            async_sql_exception_handler(),
        ):
            orm = EventORM(
                id=id,
                task_id=task_id,
                agent_id=agent_id,
                content=content.model_dump(mode="json") if content else None,
            )
            session.add(orm)
            await session.commit()
            # Refresh the ORM object to get the auto-generated sequence_id
            await session.refresh(orm)
            return self.entity.model_validate(orm)

    async def list_events_after_last_processed(
        self,
        task_id: str,
        agent_id: str,
        last_processed_event_id: str | None = None,
        limit: int | None = None,
    ) -> list[EventEntity]:
        """
        List events for a specific task and agent, optionally filtering for events
        after a specific event ID.

        Args:
            task_id: The task ID to filter by
            agent_id: The agent ID to filter by
            last_processed_event_id: Optional event ID to filter events after
            limit: Optional limit on number of results

        Returns:
            List of Event objects ordered by sequence_id
        """
        async with self.async_read_write_session_maker() as session:
            # If last_processed_event_id is provided, first find its sequence_id
            last_sequence_id = None
            if last_processed_event_id is not None:
                sequence_query = select(EventORM.sequence_id).where(
                    EventORM.id == last_processed_event_id
                )
                result = await session.execute(sequence_query)
                last_sequence_id = result.scalar_one_or_none()

            # Build the query with filters
            query = select(EventORM).where(
                and_(
                    EventORM.task_id == task_id,
                    EventORM.agent_id == agent_id,
                )
            )

            # Add sequence filter if we found a sequence_id
            if last_sequence_id is not None:
                query = query.where(EventORM.sequence_id > last_sequence_id)

            # Order by sequence ID for consistent ordering
            query = query.order_by(EventORM.sequence_id)

            # Add limit if provided
            if limit is not None:
                query = query.limit(limit)

            result = await session.execute(query)
            event_orms = result.scalars().all()

            return [EventEntity.model_validate(orm) for orm in event_orms]


DEventRepository = Annotated[EventRepository, Depends(EventRepository)]
